#
# models.py
# Michael Kirk 2013
#
# Sqlalchemy models for the database.
#
# The models were originally autogenerated by sqlautocode
#

__all__ = ['Trial', 'Node', 'Attribute', 'AttributeValue', 'Datum', 'Trait']

import os
import sqlalchemy
from sqlalchemy import *
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relation, relationship, sessionmaker, Session
from sqlalchemy.orm.exc import NoResultFound, MultipleResultsFound
import time
import decimal
import MySQLdb as mdb

from const import *
import util
from functools import wraps
from flask import current_app as app
import fpsys

# Gloabls, using weakref as these should not be used outside of module 
_FP_DBC = None    # Database connection
_FP_DBNAME = None # Database name

DeclarativeBase = declarative_base()
metadata = DeclarativeBase.metadata

class DalError(Exception):
    pass

def oneException2None(func):
#--------------------------------------------------------------------
# Decorator used for sqlalchemy one() queries, which throw exceptions if
# there isn't exactly one result. This function traps the exceptions, it
# returns the result if exactly one is found, else None.
#
    @wraps(func)
    def with_traps(*args, **kwargs):
        try:
            ret = func(*args, **kwargs)
        except NoResultFound:
            return None
        except MultipleResultsFound:
            return None
        return ret
    return with_traps


### sqlalchemy CLASSES: ######################################################################

trialTrait = Table(u'trialTrait', metadata,
    Column(u'trial_id', INTEGER(), ForeignKey('trial.id'), primary_key=True, nullable=False),
    Column(u'trait_id', INTEGER(), ForeignKey('trait.id'), primary_key=True, nullable=False),
    Column(u'barcodeAtt_id', INTEGER(), ForeignKey('nodeAttribute.id'), nullable=True)
)

class TrialTrait(DeclarativeBase):
    __table__ = trialTrait
    # relation definitions:
    barcodeAtt = relation('NodeAttribute', primaryjoin='TrialTrait.barcodeAtt_id==NodeAttribute.id')

    def addTraitInstance(self, dayCreated, tokenId):
    #-------------------------------------------------------------------
    # Create new trait instance for this trial/trait with given details.
    # To make it new, we need a value for trial/trait/seq/sample/token
    # and we can do that by varying the seq number.
    #
        db = _dbc(self)
        maxSeq = db.query(func.max(TraitInstance.seqNum)).filter(
             and_(TraitInstance.token_id == tokenId,
                  TraitInstance.trial_id == self.trial_id,
                  TraitInstance.trait_id == self.trait_id)).one()
        ti = TraitInstance()
        ti.trial_id = self.trial_id
        ti.trait_id = self.trait_id
        ti.dayCreated = dayCreated
        ti.seqNum = 1 if maxSeq[0] is None else maxSeq[0] + 1
        ti.sampleNum = 1
        ti.token_id = tokenId
        db.add(ti)
        db.commit()
        return ti

attributeValueTable = Table(unicode(TABLE_ATTRIBUTE_VALUES), metadata,
    Column(u'nodeAttribute_id', INTEGER(), ForeignKey('nodeAttribute.id'), primary_key=True, nullable=False),
    Column(u'node_id', INTEGER(), ForeignKey('node.id'), primary_key=True, nullable=False),
    Column(unicode(AV_VALUE), TEXT(), nullable=False),
)


class AttributeValue(DeclarativeBase):
    __table__ = attributeValueTable

    # relation definitions
    nodeAttribute = relation('NodeAttribute', primaryjoin='AttributeValue.nodeAttribute_id==NodeAttribute.id')
    node = relation('Node', primaryjoin='AttributeValue.node_id==Node.id')

    def getNode(self):
        return self.node

    def setValueWithTypeUpdate(self, newVal):
    # Set the value, and if the val is not an integer, set the type to text.
    # NB by default datatypes are integer, if necessary fall back to decimal,
    # and then to string
        self.value = newVal
        if not self.nodeAttribute.datatype == T_STRING and not util.isInt(newVal):
            self.nodeAttribute.datatype = T_DECIMAL if util.isNumeric(newVal) else T_STRING

    def getValueAsString(self):
        return self.value


datumTable = Table(u'datum', metadata,
    Column(u'node_id', INTEGER(), ForeignKey('node.id'), primary_key=True, nullable=False),
    Column(u'traitInstance_id', INTEGER(), ForeignKey('traitInstance.id'), nullable=False),
    Column(u'timestamp', BigInteger(), primary_key=True, nullable=False),
    Column(u'gps_long', Float(asdecimal=True)),
    Column(u'gps_lat', Float(asdecimal=True)),
    Column(u'userid', TEXT()),
    Column(u'notes', TEXT()),
    Column(u'numValue', DECIMAL(precision=11, scale=3)),
    Column(u'txtValue', TEXT()),
)

class Datum(DeclarativeBase):
    __table__ = datumTable

    # relation definitions
    node = relation('Node', primaryjoin='Datum.node_id==Node.id')
    traitInstance = relation('TraitInstance', primaryjoin='Datum.traitInstance_id==TraitInstance.id')

    @staticmethod
    def valueFieldName(traitType):
        if (traitType == T_INTEGER or
            traitType == T_DECIMAL or
            traitType == T_CATEGORICAL or
            traitType == T_DATE):
            return 'numValue'
        else:
            # traitType == T_STRING
            # traitType == T_PHOTO
            return 'txtValue'

    def isNA(self):
        return self.txtValue is None and self.numValue is None

    def getNode(self):
        return self.node

    def getGpsLong(self):
        return self.gps_long

    def getGpsLat(self):
        return self.gps_lat

    def getGpsLongStr(self):
        if (self.gps_long == 0):
            return 'NA'
        else:
            return str(format(self.gps_long, 'f'))

    def getGpsLatStr(self):
        if (self.gps_lat == 0):
            return 'NA'
        else:
            return str(format(self.gps_lat, 'f'))

    def getUserid(self):
        return self.userid

    def getNotes(self):
        return self.notes

    def getValue(self):
    #------------------------------------------------------------------
    # Return a value, how the value is stored/represented is type specific.
    # NB if the database value is null, then "NA" is returned.
    # NB - for text values, escapeHtml is applied first (to disable any html).
        dtype = self.traitInstance.trait.datatype
        value = '?'
        if dtype == T_INTEGER: value = self.numValue
        elif dtype == T_DECIMAL: value = self.numValue
        elif dtype == T_STRING: value = util.escapeHtml(self.txtValue)
        elif dtype == T_CATEGORICAL:
            value = self.numValue
            # Need to look up the text for the value:
            if value is not None:
                session = Session.object_session(self)
                traitId = self.traitInstance.trait.id
                trtCat = session.query(TraitCategory).filter(
                    and_(TraitCategory.trait_id == traitId, TraitCategory.value == value)).one()
                value = trtCat.caption
        elif dtype == T_DATE: value = self.numValue
        elif dtype == T_PHOTO:
            value = util.escapeHtml(self.txtValue)

        # if dtype ==     T_LOCATION: value = d.txtValue

        # Convert None to "NA"
        if value is None:
            value = "NA"
        return value

    def getValueAsString(self):
    #------------------------------------------------------------------
    # Return a value, how the value is stored/represented is type specific.
    # NB if the database value is null, then "NA" is returned.
    # NB - for text values, escapeHtml is applied first (to disable any html).
    # Note this is similar to getValue() but possible more efficient (important
    # if many calls) since we don't reference the traitInstance to work out the
    # type, we just consider which (of numValue and txtValue) is not NULL, for
    # at least one should be (ATTOW). Note both null indicates NA.
    # Problem, however in disambiguating int and decimal.. so let's just do it the
    # lazy way.
    #
        return str(self.getValue())

    def getTimeAsString(self):
        return util.epoch2dateTime(self.timestamp)

class Trait(DeclarativeBase):
    __tablename__ = 'trait'
    __table_args__ = {}

    # column definitions
    caption = Column(u'caption', VARCHAR(length=63), nullable=False)
    description = Column(u'description', TEXT(), nullable=False)
    id = Column(u'id', INTEGER(), primary_key=True, nullable=False)
    datatype = Column(u'datatype', INTEGER(), nullable=False)
    project_id = Column(u'project_id', INTEGER(), ForeignKey('project.id'))
    trial_id = Column(u'trial_id', INTEGER(), ForeignKey('trial.id'))

    # relation definitions
    trials = relation('Trial', primaryjoin='Trait.id==trialTrait.c.trait_id', secondary=trialTrait,
        secondaryjoin='trialTrait.c.trial_id==Trial.id')
    categories = relation('TraitCategory')  # NB, only relevant for Categorical type

    def __init__(self, caption, description, datatype, isProjectTrait, trialOrProjectId):
        self.caption = caption
        self.description = description
        self.datatype = datatype
        if isProjectTrait:
            self.trial_id = None
            self.project_id = trialOrProjectId
        else:
            self.project_id = None
            self.trial_id = trialOrProjectId

    @oneException2None
    def getCategory(self, value):
        dbc = Session.object_session(self)
        return dbc.query(TraitCategory).filter(
            and_(TraitCategory.trait_id == self.id, TraitCategory.value == value)).one()

    def getNumScoreSets(self, trialId):
        dbc = Session.object_session(self)
        return dbc.query(TraitInstance.seqNum).filter(
             and_(TraitInstance.trait_id == self.id, TraitInstance.trial_id == trialId)).group_by(
                       TraitInstance.seqNum, TraitInstance.token_id).count()

    def getName(self):
        return self.caption

    def getDescription(self):
        return self.description

    def getId(self):
        return self.id

    def getDatatypeCode(self):
        return self.datatype

    def getDatatypeName(self):
        return datatypeName(self.datatype)

    def getValueFieldName(self):
        return 'txtValue' if self.datatype == T_STRING or self.datatype == T_PHOTO else 'numValue'

    def valueFromString(self, val):
        return valueFromString(self.datatype, val)


class TraitCategory(DeclarativeBase):
    __tablename__ = 'traitCategory'
    __table_args__ = {}

    # column definitions
    caption = Column(u'caption', TEXT(), nullable=False)
    imageURL = Column(u'imageURL', TEXT())
    trait_id = Column(u'trait_id', INTEGER(), ForeignKey('trait.id'), primary_key=True, nullable=False)
    value = Column(u'value', INTEGER(), primary_key=True, nullable=False)

    # relation definitions
    trait = relation('Trait', primaryjoin='TraitCategory.trait_id==Trait.id')

    @staticmethod
    def getCategoricalTraitValue2NameMap(dbc, traitId):
    # Return dictionary providing value to caption map for specified trait.
    # The trait should be categorical, if not empty map will be returned, I think.
        cats = dbc.query(TraitCategory).filter(TraitCategory.trait_id == traitId).all()
        # util.flog('num cats: {0}'.format(len(cats)))
        retMap = {}
        for cat in cats:
            retMap[cat.value] = cat.caption
        return retMap

class TraitInstance(DeclarativeBase):
    __table__ = Table(u'traitInstance', metadata,
        Column(u'id', INTEGER(), primary_key=True, nullable=False),
        Column(u'trial_id', INTEGER(), ForeignKey('trial.id'), nullable=False),
        Column(u'trait_id', INTEGER(), ForeignKey('trait.id'), nullable=False),
        Column(u'dayCreated', INTEGER(), nullable=False),
        Column(u'seqNum', INTEGER(), nullable=False),
        Column(u'sampleNum', INTEGER(), nullable=False),
        Column(u'token_id', INTEGER(), ForeignKey('token.id'), nullable=False)
    )

    # relation definitions
    trait = relation('Trait', primaryjoin='TraitInstance.trait_id==Trait.id')
    trial = relation('Trial', primaryjoin='TraitInstance.trial_id==Trial.id')
    nodes = relation('Node', primaryjoin='TraitInstance.id==Datum.traitInstance_id', secondary=datumTable,
                     secondaryjoin='Datum.node_id==Node.id')
    token = relation('Token', primaryjoin='TraitInstance.token_id==Token.id')

    def getId(self):
        return self.id
    def getDeviceId(self):
        return self.token.getDeviceId()
    def getTrial(self):
        return self.trial
    def getTrialId(self):
        return self.trial_id
    def getSeqNum(self):
        return self.seqNum
    def getSampleNum(self):
        return self.sampleNum
    def getCreateDate(self):
        return self.dayCreated
    def numData(self):
        session = Session.object_session(self)
        count = session.query(Datum).filter(Datum.traitInstance_id == self.id).count()
        return count
    def numScoredNodes(self):
        session = Session.object_session(self)
        count = session.query(func.count(Datum.node_id.distinct())).filter(Datum.traitInstance_id == self.id).scalar()
        return count
    def stats(self):
        # MFK - this not used attow, but see stats obtained in fpWebAdmin:urlScoreSetTraitInstance()
        # That could be here, but the trouble is we don't want to get data from the db twice, once to
        # get it, and again to get the stats. Could have getStats as param to getData..
        sts = {}
        session = Session.object_session(self)
        count = session.query(Datum.node_id).filter(Datum.traitInstance_id == self.id).distinct(Datum.node_id).count()
        sts['numScored'] = count
        return sts
    def getData(self, latestOnly=False):
        #--------------------------------------------------------------------------------
        # Returns a list of Datum for this instance.
        # Sorted by node id asc, then timestamp desc.
        # Note this is returning all the data for each node, not just the latest.
        session = Session.object_session(self)
        allResults = session.query(Datum) \
            .filter(Datum.traitInstance_id == self.id) \
            .order_by(Datum.node_id.asc(), Datum.timestamp.desc()) \
            .all()
        if latestOnly:  # Remove all but newest element for each node
            llen = len(allResults)
            for i in range(len(allResults) - 1, 0, -1):
                # i goes from last index to second, we compare node_id with previous element's in allResults
                # and if the same delete the latter:
                if allResults[i].node_id == allResults[i - 1].node_id:
                    del allResults[i]
        return allResults

    def getLatestDatumPerNodeAsString(self, quoteStrings=True, metadata=True, missingValue="", orderByNodeId=False):
    #-----------------------------------------------------------------------
    # Returns an array of values, one for each node in the trial.
    # Where the node has multiple datums in this ti, the latest one is returned.
    # Iff metadata is true, then instead of single values a tuple is returned:
    # (value, timestamp, userid, gps_lat, gps_long)
    # Where there is no datums, the value is missingValue if metadata is false,
    # (otherwise a tuple of ""s).
    # Where the most recent value is NA, "NA" is returned.
    #
    # If quoteStrings is true, then string values are surrounded by double quotes,
    # with internal double quotes converted to 2 double quotes.
    # The values are ordered by row/col, or node id if specified.
    # Timestamp is given in readable form.
    #
    # NB we could pass in which metadata parameters are required, rather than getting all or none.
    #
    # If we often have to carry out retrievals like this, one for each node, then perhaps we could have
    # function that takes what fields to select, then does the qry to get one row for each node, and then
    # calls a passed function with each row.
    #
        quoteFunc = util.quote if quoteStrings else lambda x: x
        eng = _eng(self)

        # Set up sql query, this complicated due to need to get a value for every node
        # (left join) and latest of potentially multiple datums (cool trick).
        # NB we need at least one metadata field that is always not null (timestamp)
        # to be able to disambiguate NA from missing.
        qry = """
        select {0}
        from node t
          left join datum d1 on t.id = d1.node_id and d1.traitInstance_id = {1}
          left join datum d2 on d1.node_id = d2.node_id and d1.traitInstance_id = d2.traitInstance_id and d2.timestamp > d1.timestamp
        where t.trial_id = {2} and ((d2.timestamp is null and d1.traitInstance_id = {1}) or d1.timestamp is null)
        order by
        """ + ('t.id' if orderByNodeId else 'row,col')
        datatype = self.trait.datatype
        # If trait type is categorical then the values will be numbers which should be
        # converted into names (via the traitCategory table), retrieve the map for the
        # trait first:
        if datatype == T_CATEGORICAL:
            catMap = TraitCategory.getCategoricalTraitValue2NameMap(_dbc(self), self.trait_id)
        else:
            catMap = None

        valList = []
        fields = 'd1.%s, d1.timestamp' % Datum.valueFieldName(self.trait.datatype)
        if metadata:
            fields += ', d1.userid, d1.gps_lat, d1.gps_long'
        # print qry.format(fields, self.id, self.getId())
        result = eng.execute(qry.format(fields, self.id, self.trial.getId()))
        if metadata:
            for row in result:
                timestamp = row[1]
                if timestamp is None:  # no datum record case
                    valList.append(["", "", "", "", ""])
                else:
                    val = row[0]
                    if val is None: val = "NA"
                    elif datatype == T_CATEGORICAL:  # map value to name for categorical trait
                        val = quoteFunc(catMap[int(val)])
                    elif quoteStrings and (datatype == T_STRING or datatype == T_PHOTO):
                        val = quoteFunc(val)
                    elif datatype == T_INTEGER:
                        val = str(int(val))
                    valList.append([val, util.epoch2dateTime(timestamp), row[2], row[3], row[4]])
        else:
            for row in result:
                timestamp = row[1]
                if timestamp is None:  # no datum record case, so not NA
                    valList.append(missingValue)
                else:
                    val = row[0]
                    if val is None: val = "NA"
                    elif datatype == T_CATEGORICAL:  # map value to name for categorical trait
                        val = quoteFunc(catMap[int(val)])
                    elif quoteStrings and (datatype == T_STRING or datatype == T_PHOTO):
                        val = quoteFunc(val)
                    elif datatype == T_INTEGER:
                        val = str(int(val))
                    elif datatype == T_DECIMAL:
                        val = str(val)
                    valList.append(val)
        return valList

    def getTrait(self):
        return self.trait

    def createAttribute(self, name):
    # Create attribute for this ti, and write to db.
    # Returns NodeAttribute on success, else None.
        try:
            db = _dbc(self)
            att = NodeAttribute(name=name, trial_id=self.getTrialId())
            att.func = self.id
            db.add(att)
            db.commit()
        except sqlalchemy.exc.SQLAlchemyError as e:
            util.flog('Error in TraitInstance.createAttribute: {0}'.format(str(e)))
            return None
        return att

    def deleteAttribute(self):
        try:
            db = _dbc(self)
            db.query(NodeAttribute).filter_by(func=self.getId()).delete()
            db.commit()
        except sqlalchemy.exc.SQLAlchemyError as e:
            return str(e)
        return None

    @oneException2None
    def getAttribute(self):
    # Return the nodeAttribute associated with this ti, if there is one, else None.
        return _dbc(self).query(NodeAttribute).filter(NodeAttribute.func == self.id).one()

    def addData(self, aData):
    #-------------------------------------------------------------------------------------------------
    # Insert or update datum records for specified trait instance.
    # Params:
    # trtType - type of trait instance
    # aData - array of data values, each a dictionary with fields:
    #   Mandatory: node_id
    #   Optional: value, timestamp, gps_long, gps_lat, userid
    #
    # Note if value field is missing, it is assumed to be NA.
    # Return None for success, else an error message.
    #
        trtType = self.trait.datatype
        # Construct list of dictionaries of values to insert:
        try:
            valueFieldName = 'txtValue' if  trtType == T_STRING or trtType == T_PHOTO else 'numValue'
            dlist = []
            for jdat in aData:
                newrec = {
                     'node_id' : jdat.get(jDataUpload['node_id']),
                     'traitInstance_id' : self.id,
                     valueFieldName : jdat[jDataUpload['value']] if jDataUpload['value'] in jdat else None
                }
                for md in ('timestamp', 'gps_long', 'gps_lat', 'userid'):
                    if md in jdat:
                        newrec[md] = jdat[md]
                dlist.append(newrec)

            # Note we use ignore because the same data items may be uploaded more than
            # once, and this should not cause the insert to fail.
            insob = datumTable.insert().prefix_with("ignore")
            _dbc(self).execute(insob, dlist)  # error checking?
            _dbc(self).commit()
            return None
        except Exception, e:
            return "An error occurred: {0}".format(str(e))

    def addDatum(self, nodeId, timestamp, userid, gpslat, gpslong, value):
    #-------------------------------------------------------------------------------------------------
    # Insert or update datum records for specified trait instance.
    # Params:
    # dbc - db connection
    # tiID - id of trait instance
    # trtType - type of trait instance
    # aData - array of data values, json from device
    #
    # Return None for success, else an error message.
    #
        trtType = self.trait.datatype
        # Construct list of dictionaries of values to insert:
        try:
            valueFieldName = Datum.valueFieldName(trtType)
            ins = datumTable.insert().prefix_with('ignore').values({
                 DM_NODE_ID: nodeId,
                 DM_TRAITINSTANCE_ID : self.id,
                 DM_TIMESTAMP : timestamp,
                 DM_GPS_LONG : gpslong,
                 DM_GPS_LAT : gpslat,
                 DM_USERID : userid,
                 valueFieldName : value
            })
            res = _dbc(self).execute(ins)
            _dbc(self).commit()
            return None
        except Exception, e:
            util.flog('TraitInstance.addDatum: {0},{1},{2},{3},{4},{5}'.format(self.id, trtType, nodeId, timestamp, userid, gpslat))
            util.flog(e.__doc__)
            util.flog(e.message)
            return "An error occurred"

class TrialTraitNumeric(DeclarativeBase):
# Validation information specific to a given trial/trait.
    __tablename__ = 'trialTraitNumeric'
    max = Column(u'max', DECIMAL(precision=18, scale=9))
    min = Column(u'min', DECIMAL(precision=18, scale=9))
    cond = Column(u'validation', TEXT())
    trait_id = Column(u'trait_id', INTEGER(), ForeignKey('trait.id'), primary_key=True, nullable=False)
    trial_id = Column(u'trial_id', INTEGER(), ForeignKey('trial.id'), primary_key=True, nullable=False)
    def getMin(self):
        return None if self.min is None else self.min.normalize()  # stripped of unnecessary zeroes
    def getMax(self):
        return None if self.max is None else self.max.normalize()

# class TraitString
# Validation information specific to a given trial/trait.
class TraitString(DeclarativeBase):
    __tablename__ = 'traitString'
    trait_id = Column(u'trait_id', INTEGER(), ForeignKey('trait.id'), primary_key=True, nullable=False)
    trial_id = Column(u'trial_id', INTEGER(), ForeignKey('trial.id'), primary_key=True, nullable=False)
    pattern = Column(u'pattern', TEXT())


#
# class ScoreSet
# NOT a database class, but a container for a set of traitInstances that
# make up a scoreSet
#
class ScoreSet():
# class ScoreSet(DeclarativeBase):
#     __tablename__ = 'scoreSet'
#     id = Column(u'id', INTEGER(), primary_key=True, nullable=False)
#     trial_id = Column(u'trial_id', INTEGER(), ForeignKey('trial.id'), nullable=False)
#     trait_id = Column(u'trait_id', INTEGER(), ForeignKey('trait.id'), nullable=False)
#     dayCreated = Column(u'dayCreated', INTEGER(), nullable=False)
#     seqNum = Column(u'seqNum', INTEGER(), nullable=False)
#     token_id = Column(u'token_id', INTEGER(), ForeignKey('token.id'), nullable=False)
#
#     # Relations:
#     token = relation('Token', primaryjoin='ScoreSet.token_id==Token.id')

    def __init__(self, trait_id, seqNum, tokenId):
    # Perhaps we need to create db record here now?
        self.trait_id = trait_id
        self.seqNum = seqNum
        self.token_id = tokenId
        self.instances = []
    def addInstance(self, ti):
        self.instances.append(ti)
    def getInstances(self):
        return self.instances
    def getFPId(self):
        return 0 if len(self.instances) <= 0 else self.instances[0].id
    def getTrait(self):
        if len(self.instances) <= 0:
            return ''
        return self.instances[0].getTrait()
    
class Project(DeclarativeBase):
    __tablename__ = 'project'
    __table_args__ = {}

    # column definitions:
    id = Column(u'id', INTEGER(), primary_key=True, nullable=False)  # MFK Shouldn't this be FK to fpsys.project?
    up_id = Column('up_id', INTEGER(), ForeignKey('project.id'))
    name = Column(u'name', VARCHAR(length=63), nullable=False)
    contactName = Column(u'contactName', TEXT())
    contactEmail = Column(u'contactEmail', TEXT())

    # relation definitions:
    trials = relationship('Trial')
    upProject = relationship('Project', remote_side=[id])

    def getName(self):
        return self.name
    def setName(self, name):
        self.name = name
    def getId(self):
        return self.id
    def getTrials(self):
        return self.trials
    
    def setContactName(self, name):
        self.contactName = name        
    def setContactEmail(self, email):
        self.contactEmail = email
    def save(self):  # Not good, is saving whole session, not just project
        dbc = Session.object_session(self)
        dbc.commit()
        
    def path(self):
    #-----------------------------------------------------------------------
    # Recursion - whee!
    #
        if self.upProject is not None:
            return '{0}/{1}'.format(self.upProject.path(), self.getName())
        else:
            return self.getName()

    def getTraits(self):
        session = Session.object_session(self)
        return session.query(Trait).filter(Trait.project_id == self.id).all()
    
    @oneException2None
    def getTrait(self, traitId):
    #-------------------------------------------------------------------------------------------------
        dbc = _dbc(self)
        return dbc.query(Trait).filter(Trait.id == traitId).one()
    
    def deleteTrait(self, traitId):
    #-------------------------------------------------------------------------------------------------
    # See Trial.deleteTrait.
    # This should be (and we should check) that this is a project trait, not a trial trait.
    # Also that any peripheral data is cleaned up. NB, it seems traitInstance does NOT delete cascade
        dbc = _dbc(self)
        return dbc.query(Trait).filter(Trait.id == traitId).delete()
    
    def newTrait(self, caption, description, datatype, typeData=None):
    #-----------------------------------------------------------------------
    # Create trait in db, from data from html form.
    # trialId is id of trial if a local trait, else it is -1.
    # Returns error message if there's a problem, else None.
    #
        print 'in newTrait=================================='
        dbsess = _dbc(self)
        datatypeCode = TRAIT_TYPE_TYPE_IDS[datatype]
        # We need to check that caption is unique within the trial - for local anyway, or is this at the add to trialTrait stage?
        # For creation of a system trait, there is not an automatic adding to a trial, so the uniqueness-within-trial test
        # can wait til the adding stage.
    
        # Check for duplicate captions, probably needs to use transactions or something, but this will usually work:
        # If system trait, check there's no other system trait with same caption:
        projTraits = self.getTraits()
        for x in projTraits:
            if x.caption == caption:
                return 'Error: A system trait with this caption already exists'
            
        isProjectTrait = True
        ntrt = Trait(caption, description, datatypeCode, isProjectTrait, self.getId())
        dbsess.add(ntrt)
#         dbsess.commit()   # Add the trait to the db (before trait specific stuff which may need id).
        dbsess.flush()

        print 'about to type specific processing'        
        # Trait type specific processing:
        if int(ntrt.datatype) == T_CATEGORICAL and typeData is not None:
            print 'in if'
            for caption, value in typeData.iteritems():
#                 caption = cat.get("caption")
#                 value = cat.get("value")
                print 'foo', caption, value
                # Determine if this is a new category or an existing one.
                # Trait categories are identified by the value (within a trait).
                tcat = ntrt.getCategory(value)
                newCat = tcat is None
                if newCat:
                    # Add new trait category:
                    tcat = TraitCategory()
                    tcat.value = value
                    tcat.caption = caption
                    tcat.trait_id = ntrt.id
#                     tcat.imageURL = imageURL
                    dbsess.add(tcat)
                    print 'added'
                else:
                    raise DalError("Duplicate category")
#                     util.flog("Existing category: cap:{0} value:{1}".format(caption, value))
#                     # This is an existing category, update caption, or image URL if necessary:
#                     if tcat.caption != caption:
#                         tcat.caption = caption
#                     # (Re)Set the image if necessary. There is a difficulty here.
#                     # NB If an image was already set, and user doesn't change it, it will come back empty.
#                     # And we don't want to set it to nothing in this case. The problem remains, however, as
#                     # to how can the user explicitly set it to no image?
#                     if imageURL is not None:
#                         tcat.imageURL = imageURL
                # NB: no commit - we assume calling function will do it.

        dbsess.commit()
        
#         if int(ntrt.datatype) == T_CATEGORICAL:
#             _newTraitCategorical(sess, request, ntrt)
#         dbsess.add(ntrt)
#         dbsess.commit()
        return ntrt

    def newTrial(self, name, site, year, acro):  # see comment below , i1name=None, i2name=None):
    # Creates new trial in the database with given details.
    # Raises DalError if this fails.
    # MFK - need to mv commit and rollback out of here
        session = Session.object_session(self)
        # Check if there is already a trial by that name:
        numNames = session.query(Trial).filter(Trial.name == name).count()
        if numNames != 0:
            raise DalError("There is already a trial with that name")
        try:
            ntrial = Trial(self.id, name, site, year, acro)
            session.add(ntrial)
            session.commit()
# Code to set index names, not needed ATTOW as the single call to this is followed by
# a call to trialProperties.processPropertiesForm which does this.
#             # Add index names:
#             if i1name is not None:
#                 session.add(TrialProperty(ntrial.id, INDEX_NAME_1, i1name))
#                 if i2name is not None:   # NB i2name only used if i1name is present.
#                     session.add(TrialProperty(ntrial.id, INDEX_NAME_2, i2name))
#                 session.commit()
        except sqlalchemy.exc.SQLAlchemyError as e:
            session.rollback()  # This should ensure bad trial is not created in db
            raise DalError("Database error ({0})".format(e.__str__()))
        return ntrial
    
    @oneException2None
    def getTrialById(self, trialId):
    #-----------------------------------------------------------------------
    # Returns trial object with given id if found, else None.
        dbc = _dbc(self)
        return dbc.query(Trial).filter(Trial.id == trialId).one()
        
    @staticmethod
    def delete(dbc, projId):
    #-----------------------------------------------------------------------
    # Delete specified project from the DB.
        dbc.query(Project).filter(Project.id == projId).delete()
        dbc.commit()
        return None
        
    @staticmethod
    def countProjects(dbc):
        return dbc.query(Project).count()
    
    @staticmethod
    @oneException2None
    def getById(dbc, projectId):
    #-----------------------------------------------------------------------
    # Returns project object with given id if found, else None.
        return dbc.query(Project).filter(Project.id == projectId).one()
    
    @staticmethod
    @oneException2None
    def getByName(dbc, projectName):
    #-----------------------------------------------------------------------
    # Returns project object with given name if found, else None.
        return dbc.query(Project).filter(Project.name == projectName).one()

    @staticmethod
    def makeNewProject(projectName, ownDatabase, contactName, contactEmail, adminLogin):
    # Create new database/project. Returns new project obj on success else raises DalError.
    # Should probably move the relevant bits of this out to fpsys.
   
        if not ownDatabase:
            raise DalError('Shared databases not supported yet')
        
        # Check parameters validity:
        if not util.isValidIdentifier(projectName):
            raise DalError('Invalid project name')
        if not util.isValidName(contactName):
            raise DalError('Invalid contact name')
        if not util.isValidEmail(contactEmail):
            raise DalError('Invalid xcontact email address')
        if not util.isValidIdentifier(adminLogin):
            raise DalError('invalid login name')
        # Check project name doesn't already exist:
        if fpsys.getProjectDBname(projectName) is not None:
            raise DalError('Project with name {} already exists'.format(projectName))

        dbname = dbName4Project(projectName)
        sql = 'create database {}; use {};'.format(dbname, dbname)
        with open(app.config['FP_DB_CREATE_FILE']) as sqlfile:
            sql += sqlfile.read()

        sql += 'insert fpsys.project (name, dbname) values ("{}", "{}");'.format(projectName, dbname)
        # does above return newly created id - or can we get it somehow?
        sql += 'insert project (id, up_id, name, contactName, contactEmail) values ' + \
        '((select id from fpsys.project where name="{}"), null, "{}", "{}", "{}");'.format(projectName,
            projectName, contactName, contactEmail)
        sql += 'flush privileges;'
# See if we can remove this - it's redundant and assumes single project per db:        
        sql += 'insert system (name, value) values ("contactName", "{}"), ("contactEmail", "{}");'.format(contactName, contactEmail)
        try:
            con = fpsys.getFpsysDbConnection() 
            cur = con.cursor()
            cur.execute(sql)
            con.commit()  # not sure this is necessary
            cur.close()
            con.close()
            # How to check if succeeded?
#             resRow = cur.fetchone()
#             return None if resRow is None else resRow[0]
        except mdb.Error, e:
            raise DalError('Error creating project: ' + str(e))
        
        dbc = getDbConnection(dbname)
        proj = Project.getByName(dbc, projectName)
        #dbc.close()
        return proj

class Trial(DeclarativeBase):
    __tablename__ = 'trial'
    __table_args__ = {}

    # column definitions:
    acronym = Column(u'acronym', TEXT())
    id = Column(u'id', INTEGER(), primary_key=True, nullable=False)
    project_id = Column(u'project_id', INTEGER(), ForeignKey('project.id'))
    name = Column(u'name', VARCHAR(length=63), nullable=False)
    site = Column(u'site', TEXT())
    year = Column(u'year', TEXT())

    # relation definitions:
    traits = relation('Trait', primaryjoin='Trial.id==trialTrait.c.trial_id', secondary=trialTrait, secondaryjoin='trialTrait.c.trait_id==Trait.id')
    nodeAttributes = relationship('NodeAttribute')
    nodes = relationship('Node', order_by='Node.id')
    trialProperties = relationship('TrialProperty')
    project = relation('Project', primaryjoin='Trial.project_id==Project.id')

    def __init__(self, projectId, name, site, year, acro):
        self.project_id = projectId
        self.name = name
        self.site = site
        self.year = year
        self.acronym = acro
        super(Trial, self).__init__()

    def getId(self):
        return self.id
    def getProject(self):
        return self.project
    def getName(self):
        return self.name
    def getSite(self):
        return self.site
    def getYear(self):
        return self.year
    def getAcronym(self):
        return self.acronym

    def getAttributes(self):
    # MFK - make this getProperties (maybe not, we already use that word) and include, at least, barcode
        return self.nodeAttributes

    @staticmethod
    def new(dbc, tname, tsite, tyear, tacro):
    # NB may throw exceptions, not handled here.
    # MFK ############ Should be redundant now
        try:
            ntrial = Trial()
            ntrial.name = tname
            ntrial.site = tsite
            ntrial.year = tyear
            ntrial.acronym = tacro
            dbc.add(ntrial)
            dbc.commit()
        except sqlalchemy.exc.SQLAlchemyError as e:
            # Delete trial and raise exception on error:
            Trial.delete(dbc, ntrial.id)
            raise DalError("Database error ({0})".format(e.__str__()))
        return ntrial

    def addOrGetNode(self, row, col):
        try:
            session = Session.object_session(self)
            tu = session.query(Node).filter(and_(Node.trial_id == self.id, Node.row == row,
                                                      Node.col == col)).one()
        except NoResultFound:
            tu = Node()
            tu.row = row
            tu.col = col
            tu.trial_id = self.id
            session.add(tu)
            session.commit()
        except MultipleResultsFound:
            return None
        return tu

    def getNodeId(self, row, col):
    #-------------------------------------------------------------------------------------------------------
    # Return node id for given row/col or None if not found or not unique
    #
        try:
            session = Session.object_session(self)
            nodeId = session.query(Node.id).filter(
                        and_(Node.trial_id == self.id, Node.row == row, Node.col == col)).one()
        except NoResultFound:
            return None
        except MultipleResultsFound:
            return None
        return nodeId.id

    def getNodeIdFromBarcode(self, barcode):
    #-------------------------------------------------------------------------------------------------------
    # Return node id for given barcode or None if not found or not unique
    #
        try:
            session = Session.object_session(self)
            nodeId = session.query(Node.id).filter(and_(Node.trial_id == self.id, Node.barcode == barcode)).one()
        except NoResultFound:
            return None
        except MultipleResultsFound:
            return None
        return nodeId.id

    def numScores(self):
        tis = self.getTraitInstances()
        count = 0
        for ti in tis:
            count += ti.numData()
        return count

    def numScoreSets(self):
        ss = self.getScoreSets()
        return len(ss)

    @oneException2None
    def getTraitInstance(self, tiId):
    #-----------------------------------------------------------------------
    # Return traitInstance if one with given id is in this trial. Or None if problem.
        dbc = _dbc(self)
        return dbc.query(TraitInstance).filter(and_(
            TraitInstance.trial_id == self.id, TraitInstance.id == tiId)).one()

    def getTraitInstances(self):
    #-----------------------------------------------------------------------
    # Return all the traitInstances for this trial, ordered by trait, token, seqnum,
    # dayCreate, samplenum. So traitInstances in the same scoreSet are contiguous.
    # NB sorting by dayCreated shouldn't be necessary, but is temporarily needed
    # - see comment on getScoreSets().
        session = Session.object_session(self)
        return session.query(TraitInstance).filter(
            TraitInstance.trial_id == self.id).order_by(
            TraitInstance.trait_id, TraitInstance.token_id, TraitInstance.seqNum,
            TraitInstance.dayCreated, TraitInstance.sampleNum).all()

    def getScoreSets(self):
    #----------------------------------------------------------------------------------------------------
    # Returns list of ScoreSets for this trial.
    # NB the use of dayCreated in the comparison shouldn't be necessary, but it is at the moment
    # for a fix we have for a bug in the app where a scoreset made after deleting a scoreset (of the
    # same trait) could cause an overwrite of the first scoreset on the server. This now fixed,
    # but using dayCreated catches most instances of this. When all clients are upgraded, this
    # can go.
    # NB the returned list of scoreSets is sorted by trait, token...
    #
        scoreSets = []
        tiList = self.getTraitInstances()
        lastSeqNum = -1
        lastTraitId = -1
        lastTokenId = -1
        lastDayCreated = -1
        for ti in tiList:  # Note we have assumptions about ordering in tiList here
            traitId = ti.trait_id
            seqNum = ti.seqNum
            tokenId = ti.token_id
            dayCreated = ti.dayCreated
            if seqNum != lastSeqNum or traitId != lastTraitId or tokenId != lastTokenId or dayCreated != lastDayCreated:
                # First ti in a new scoreSet, create and add the ScoreSet:
                nss = ScoreSet(traitId, seqNum, tokenId)
                scoreSets.append(nss)
            nss.addInstance(ti)
            lastSeqNum = seqNum
            lastTraitId = traitId
            lastTokenId = tokenId
            lastDayCreated = dayCreated
        return scoreSets

    def getNodes(self):
    # Returns list of Nodes, sorted by node id.
        return self.nodes
    def getNode(self, nodeId): # Replace this with getNodeById below
        return getNode(_dbc(self), nodeId)
    @oneException2None
    def getNodeById(self, nodeId):
    # New version of above, checking that node is within trial.
        dbc = _dbc(self)
        return dbc.query(Node).filter(and_(Node.id == nodeId, Node.trial_id==self.id)).one()


    def getNodesSortedRowCol(self):
        # Return nodes for the specified trial, sorted by row/col
        dbc = Session.object_session(self)
        return dbc.query(Node).filter(Node.trial_id==self.id).order_by(Node.row, Node.col).all()

    def getNodesSortedById(self):  # Not used, returns ids as tuple anyway
        # Return node ids for the specified trial, sorted by id.
        db = _dbc(self)
        return db.query(Node).filter(Node.trial_id==self.id).order_by(Node.id).all()

    def getNodeIds(self):  # Not used, returns ids as tuple anyway
        # Return node ids for the specified trial, sorted by id.
        db = _dbc(self)
        return db.query(Node.id).filter(Node.trial_id==self.id).order_by(Node.id).all()

    def navIndexName(self, indexOrder):
    #----------------------------------------------------------------------------------------------------
    # Return the name to use for the index attribute identified by indexOrder.
    # Calls static version of the function, which we need since many callers have trialId but not object.
        return navIndexName(Session.object_session(self), self.id, indexOrder)

    def navIndexNames(self):
        return (self.navIndexName(0), self.navIndexName(1))
    
    def setNavIndexNames(self, index1Name, index2Name):
    # Set nav index names, if None, these get default values. Otherwise they
    # must be valid identifiers.
    # Return None or errmsg.
        db = _dbc(self)
        if index1Name is None: index1Name = INDEX_NAME_1_DEFAULT
        if index2Name is None: index2Name = INDEX_NAME_2_DEFAULT
        if not util.isValidIdentifier(index1Name): return 'Invalid row alias'
        if not util.isValidIdentifier(index1Name): return 'Invalid row alias'
        db.merge(TrialProperty(self.getId(), INDEX_NAME_1, index1Name))
        db.merge(TrialProperty(self.getId(), INDEX_NAME_2, index2Name))
        db.commit()
        return None

    @staticmethod
    def getTraitInstancesForTrial(dbc, trialID):
    #-----------------------------------------------------------------------
    # Return all the traitInstances for the specified trial,
    # ordered by trait, token, seqnum, samplenum.
        return dbc.query(TraitInstance).filter(
            TraitInstance.trial_id == trialID).order_by(
            TraitInstance.trait_id, TraitInstance.token_id, TraitInstance.seqNum, TraitInstance.sampleNum).all()

    @staticmethod
    def delete(dbc, trialId):
    #-----------------------------------------------------------------------
    # Delete specified trial from the DB - I'm not sure where this leaves the in memory
    # objects..
        dbc.query(Trial).filter(Trial.id == trialId).delete()
        dbc.commit()
        return None

    def deleteTrait(self, traitId):
    #-----------------------------------------------------------------------
    # Delete specified trait from the DB, provided there is no score data for
    # the trait. Returns boolean indication success or not.
    #
        db = _dbc(self)
        # Determine if there is any score data:
        numTis = db.query(TraitInstance).filter(
            and_(TraitInstance.trial_id == self.id, TraitInstance.trait_id == traitId)).count()
        if numTis <= 0:
            return False
        # If local trait, delete trait (references should follow by cascade).
        # If system trait, delete the records associated with the trial ???
        trt = getTrait(db, traitId)
        if trt.trial_id is not None:
            trt.delete()  # does this work
            db.commit()
            return True
        if trt.project_id is not None:  # this should be automatic
            pass
        return False

    def path(self):
    #---------------------------------------------------------------------------------------
    # Return project path and trial name
    #
        return '{0}/{1}'.format(self.project.path(), self.name)

    def getDataLongForm(self, showTime, showUser, showGps, showAttributes):
    #---------------------------------------------------------------------------------------
    # Return score data for the trial in tab separated long form.
    # Keeping an eye on efficiency, we iterate over scoresets and do a single sql query on each.
    # Output is one line per datum:
    # TraitName, ssId, nodeId, sampleNum, value [,time] [,user] [,gps]
    # NB this function's sibling getDataWideFormTSV is in fpWebAdmin. Maybe this should be too -
    # except for the sql bit. Could have func here that return the sql result (note however that
    # I think the result can only be iterated over, once. It isn't a normal data structure.
    #
        # Add file info:
        out = '# FieldPrime long form trial data\n'
        out += '# Trial: {0}\n'.format(self.path())
        out += '# Creation time: {0}\n'.format(time.strftime("%Y-%m-%d %H:%M:%S"))

        # Add headers:
        sep = '\t'
        metas = ''
        out += "Trait\tfpScoreSetID\tScoreSetCreationDate\tfpNodeId\tsampleNum\tValue"
        numCols = 5
        if showTime:
            out += '\tTime'
            metas += ',FROM_UNIXTIME(timestamp/1000)'
            numCols += 1
        if showUser:
            out += '\tUser'
            metas += ',userid'
            numCols += 1
        if showGps:
            out += '\tLatitude\tLongitude'
            metas += ',gps_lat,gps_long'
            numCols += 1
        if showAttributes:
            out += sep + self.navIndexName(0) + sep + self.navIndexName(1)
            trlAttributes = self.getAttributes()
            for tua in trlAttributes:
                out += sep + tua.name
            nodes = self.getNodesSortedById()  # get list of node ids in same order as elements of attValList
            attValList = self.getAttributeColumns(trlAttributes, True)  # Get all the att vals in advance
        out += '\n'

        # Add data rows - iterate over scoresets:
        engine = _eng(self)
        sql = '''
        select d.node_id, ti.sampleNum, {{0}} {0}
        from datum d join traitInstance ti on d.traitInstance_id = ti.id join trial t on ti.trial_id = t.id
        where t.id = {1} and ti.id in {{1}}
        order by d.node_id, ti.id
        '''.format(metas, self.getId())
        scoreSets = self.getScoreSets()
        for ss in scoreSets:
            trait = ss.getTrait()
            traitName = trait.getName()
            ssId = ss.getFPId()
            tis = ss.getInstances()
            ssCreateDate = tis[0].getCreateDate() if len(tis) > 0 else None
            tiIdList = '('
            for ti in tis:
                if len(tiIdList) > 1:
                    tiIdList += ','
                tiIdList += str(ti.id)
            tiIdList += ')'
            valueField = trait.getValueFieldName()
            result = engine.execute(sql.format(valueField , tiIdList))
            nodeIdsIndex = 0;
            for row in result:
                out += '{0}\t{1}\t{2}'.format(traitName, ssId, ssCreateDate)
                for i in range(0, len(row)):
                    # Need to detect NA, this is where the value field (3rd column) is null
                    if i == 2:
                        out += '\t{0}'.format('NA' if row[i] is None else row[i])
                    else:
                        out += '\t{0}'.format(row[i])
                if showAttributes:
                    nodeId = long(row[0])
                    try:
                        while nodeId > nodes[nodeIdsIndex].getId():  # MFK should check for index error
                            nodeIdsIndex += 1
                    except IndexError:
                        return 'Unexpected Error: IndexError in getDataLongForm'
                    out += sep + str(nodes[nodeIdsIndex].row)
                    out += sep + str(nodes[nodeIdsIndex].col)
                    for ind in range(len(trlAttributes)):
                        out += sep + attValList[ind][nodeIdsIndex]
                out += '\n'
        return out

    def getAttribute(self, name):
    #---------------------------------------------------------------------------------------
    # Return named attribute, if it's in this trial
    #
        for att in self.getAttributes():
            if att.name == name:
                return att
        return None
    
    @oneException2None
    def getAttribute2(self, name):
        return _dbc(self).query(NodeAttribute).filter(
            and_(NodeAttribute.trial_id==self.getId(), NodeAttribute.name==name)).one()
    
    def createAttribute(self, attribute):
        name = attribute.get('name')
        if name is None or not util.isValidIdentifier(name):
            raise DalError("name missing or invalid in attribute")
        datatype = attribute.get('datatype')
        if datatype is None or datatype == 'text': datatype = T_STRING
        elif datatype == 'integer': datatype = T_INTEGER
        elif datatype == 'decimal': datatype = T_DECIMAL
        else:
            raise DalError("Invalid datatype")

        # Check if attribute with name already exists:
        if self.getAttribute2(name) is not None:
            return None
        nattr = NodeAttribute(name=name, trial_id=self.getId(), datatype=datatype)
        return nattr
    
    def createNode(self, jnode):
    # expects:    {'index1': - , 'index2': - , 'attvals':{<attName>:<attValue>, ...}}
    # returns node, or raises exception.
    # Commit is the responsibility of the caller.
        try:
            ind1 = int(jnode.get('index1'))
            ind2 = int(jnode.get('index2'))
        except Exception: #ValueError, TypeError:
            raise DalError('index1 and index2 must be present, and valid integers')
        atts = jnode.get('attvals')
        if self.getNodeId(ind1, ind2) is not None:
            raise DalError('A node with index values {}, {} already exists'.format(ind1, ind2))
        node = Node()
        node.row = ind1
        node.col = ind2
        node.trial_id = self.getId()
        
        dbc = _dbc(self)
        dbc.add(node)
        dbc.flush()
        
        if atts is not None:
            currAtts = self.getAttributes()#[att.name for att in self.getAttributes()]
            for attname in atts:
                # Get attribute
                currAtt = None
                for att in currAtts:
                    if att.getName() == attname:
                        currAtt = att
                        break
                # check attribute exists:
                if currAtt is None:                
                    raise DalError('unknown node attribute referenced: ' + attname)
                
                # now maybe check type and add value
                av = AttributeValue()
                av.nodeAttribute = currAtt
                av.node = node
                av.value = str(atts[attname])
                dbc.add(av)
            
        return node
    
    def updateNode(self, nodeId, jnode):
    # expects:    {'index1': - , 'index2': - , 'attvals':{<attName>:<attValue>, ...}}
    # returns node, or raises exception.
    # Commit is the responsibility of the caller.
        # Get the node (must be in this trial:
        node = self.getNodeById(nodeId)
        if node is None:
            raise DalError('Node does not exist')
        ind1 = jnode.get('index1')
        ind2 = jnode.get('index2')    
        try:
            if ind1 is not None:                
                node.row = int(ind1)
            if ind2 is not None:                
                node.col = int(ind2)
        except Exception: #ValueError, TypeError:
            raise DalError('index1 and index2 must valid integers')
# Should we check new ind1/ind2 is unique? This is NOT in table specs        
        atts = jnode.get('attvals')
        if self.getNodeId(ind1, ind2) is not None:
            raise DalError('A node with index values {}, {} already exists'.format(ind1, ind2))
        node = Node()
        node.row = ind1
        node.col = ind2
        node.trial_id = self.getId()
        
        dbc = _dbc(self)
#         dbc.add(node)
#         dbc.flush()
        
        if atts is not None:
            currAtts = self.getAttributes()#[att.name for att in self.getAttributes()]
            for attname in atts:
                # Get attribute
                currAtt = None
                for att in currAtts:
                    if att.getName() == attname:
                        currAtt = att
                        break
                # check attribute exists:
                if currAtt is None:                
                    raise DalError('unknown node attribute referenced: ' + attname)
                
                # now maybe check type and add value
                av = AttributeValue()
                av.nodeAttribute = currAtt
                av.node = node
                av.value = str(atts[attname])
                dbc.add(av)            
        return node

    def deleteNode(self, nodeId):
    # No commit
        try:
            db = _dbc(self)
            db.query(Node).filter(and_(Node.id==nodeId, Node.trial_id==self.getId())).delete()
        except sqlalchemy.exc.SQLAlchemyError as e:
            return str(e)
        return None

    def hasNodeProperty(self, name):
        if name in self.navIndexNames() or name.lower() == 'barcode':
            return True

    def getTrait(self, trtName):
    #---------------------------------------------------------------------------------------
    # Return named trait, if it's in this trial.
    #
        for trt in self.traits:
            if trt.getName() == trtName:
                return trt
        return None
    
    def addTrait(self, trait):
    #---------------------------------------------------------------------------------------
    # Add trait to trial, if it's not already in it.
    # NB- no commit.
        traitId = trait.id
        for trt in self.traits:
            if traitId == trt.id: return
        return self.traits.append(trait)

    def getDataColumns(self, tiList, quoteStrings=True, metadata=True):
    #-----------------------------------------------------------------------
    # Returns a list of lists of tuples. Each element in the top list is for one of the ti in tiList (in order).
    # The element for a ti is a list of tuples, for for each node in the trial, ordered by row/col.
    # NB, a tuple of empty strings will be used for nodes without a value.
    # The tuples are the most recent value and metadata for the node/ti in the trial
    # Timestamp is given in readable form.
    #
    # NB main work now done in getLatestDatumPerNodeAsString, perhaps this func no longer needed?
        outList = []
        for ti in tiList:
            valList = ti.getLatestDatumPerNodeAsString(quoteStrings=quoteStrings, metadata=metadata)
            outList.append(valList)
        return outList

    def getAttributeColumns(self, attList, orderByNodeId=False):
    #-----------------------------------------------------------------------
    # Returns a list of columns one for each attribute in attList - each column
    # being an array of attribute values with one entry for each node in the trial.
    # The columns are in the same order as attList, and the column entries are
    # orderedby row/col by default, or node id if specified.
    # Missing values are given as the empty string.
    #
        attValList = []
        for att in attList:
            attValList.append(att.getValues(orderByNodeId))
        return attValList

    def addNodeNotes(self, tokenStr, notes):
    #-------------------------------------------------------------------------------------------------
    # Return None for success, else an error message.
    # MFK need check nodeIds are in correct trial
    #
        # Convert tokenStr to its token id. The token should exist in the token table,
        # otherwise something fishy may be going on.
        try:
            db = _dbc(self)
            tokenId = Token.getTokenId(db, tokenStr)
        except Exception, e:
            return "Token not found ({0})".format(e.__str__())
        try:
            dlist = []
            for n in notes:
                nodeId = n.get(jNotesUpload['node_id']) or n.get('trialUnit_id')  # check int and valid id in trial
                # nodeId = long(nodeId)

                timestamp = n[jNotesUpload['timestamp']]  # check valid
                userid = n[jNotesUpload['userid']]
                note = n[jNotesUpload['note']]
                newrec = {
                     'node_id' : nodeId,
                     'timestamp' : timestamp,
                     'userid' : userid,
                     'token_id' : tokenId,
                     'note' : note
                }
                dlist.append(newrec)

            # Note we use ignore because the same data items may be uploaded more than
            # once, and this should not cause the insert to fail.
            insob = NodeNote.__table__.insert().prefix_with("ignore")
            db.execute(insob, dlist)  # error checking?
            db.commit()
            return None
        except Exception, e:
            return "An error occurred: {0}".format(str(e))

#         qry = 'insert ignore into {0} ({1}, {2}, {3}, {4}, {5}) values '.format(
#             'nodeNote', 'node_id', 'timestamp', 'userid', 'token_id', 'note')
#         if len(notes) <= 0:
#             return None
#         for n in notes:
#             try:
#                 nodeId =  n.get(jNotesUpload['node_id']) or n.get('trialUnit_id')
#                 qry += '({0}, {1}, "{2}", {3}, "{4}"),'.format(
#                     nodeId, n[jNotesUpload['timestamp']],
#                     n[jNotesUpload['userid']], tokenId, n[jNotesUpload['note']])
#                 # Should be this, but have to cope with 'trialUnit_id' coming
#                 # from clients for a while..
#                 # qry += '({0}, {1}, "{2}", {3}, "{4}"),'.format(
#                 #     n[jNotesUpload['node_id']], n[jNotesUpload['timestamp']],
#                 #     n[jNotesUpload['userid']], tokenId, n[jNotesUpload['note']])
#             except Exception, e:
#                 return 'Error parsing note ' + e.args[0]

    def setTrialProperty(self, key, value):
    # NB - does not commit
        db = _dbc(self)
        newProp = TrialProperty(self.getId(), key, value)
        newProp = db.merge(newProp)        
    def setTrialPropertyBoolean(self, key, value):
        self.setTrialProperty(key, 'true' if value else 'false')
        
    def getTrialProperty(self, key):
    # Returns value from db, or None if not set
        return TrialProperty.getPropertyValue(_dbc(self), self.getId(), key)
    def getTrialPropertyBoolean(self, key):
    # Returns None, True, False, or raises DalError
        val = self.getTrialProperty(key)
        if val is None: return None
        if val == 'true': return True
        if val == 'false': return False
        raise DalError('unexpected value for {}'.format(key))
        
def navIndexName(dbc, trialId, indexOrder):
# Static version of Trial method navIndexName, exists because some callers
# of this function may not already have a trial instance, just a trialId.
# Return the name to use for the specified index attribute.
#
    indexName = [INDEX_NAME_1, INDEX_NAME_2][indexOrder]
    try:
        val = dbc.query(TrialProperty).filter(
                    and_(TrialProperty.trial_id == trialId, TrialProperty.name == indexName)
                    ).one().value
    except NoResultFound:
        return [INDEX_NAME_1_DEFAULT, INDEX_NAME_2_DEFAULT][indexOrder]
    else:
        return val


#
# TrialProperty
# Table for trial attributes.
# NB: what attributes are available to be set are hard-coded into the software.
# Users may change the values of the hardcoded set, but not create new attributes.
# Note also that the app web service will sent whatever is in this table (regardless)
# of what the admin web service currently supports.
# The values in the table are text, but the real types, as presented to the user, could
# be boolean, categorical, numeric etc. They are to be sent to the app via json however
# so must map to some text representation anyway. We could perhaps give them a type, where
# the types are those supported by json. But for them to be of use on the app, the app
# code must know the type anyway.
# Anyway, if we added tables to list the supported types, then the admin interface at least
# could be driven from the tables, and to add a new attribute we would only need adjust
# the tables. But we don't have that attow. On the other hand, a table hardcoded in the
# software isn't necessarily any harder to adjust.
#
class TrialProperty(DeclarativeBase):
    __tablename__ = 'trialProperty'
    __table_args__ = {}

    # column definitions:
    trial_id = Column(u'trial_id', INTEGER(), ForeignKey('trial.id'), primary_key=True, nullable=False)
    name = Column(u'name', TEXT(), primary_key=True)
    value = Column(u'value', TEXT())

    def __init__(self, tid, name, value):
        self.trial_id = tid
        self.name = name
        self.value = value
        super(TrialProperty, self).__init__()

    @staticmethod
    @oneException2None
    def getPropertyValue(dbc, trialId, propName):
        return dbc.query(TrialProperty).filter(
                and_(TrialProperty.trial_id == trialId, TrialProperty.name == propName)
                ).one().value


class Node(DeclarativeBase):
    __tablename__ = 'node'
    __table_args__ = {}

    # column definitions
    barcode = Column(u'barcode', TEXT())
    col = Column(u'col', INTEGER(), nullable=False)
    description = Column(u'description', TEXT())
    id = Column(u'id', INTEGER(), primary_key=True, nullable=False)
    row = Column(u'row', INTEGER(), nullable=False)
    trial_id = Column(u'trial_id', INTEGER(), ForeignKey('trial.id'), nullable=False)
    longitude = Column(u'longitude', Float(asdecimal=False))
    latitude = Column(u'latitude', Float(asdecimal=False))

    # relation definitions
    trial = relation('Trial', primaryjoin='Node.trial_id==Trial.id')
# These seem not to be used:
#     nodeAttributes = relation('NodeAttribute', primaryjoin='Node.id==AttributeValue.node_id',
#         secondary=attributeValueTable, secondaryjoin='AttributeValue.nodeAttribute_id==NodeAttribute.id')
#     traitInstances = relation('TraitInstance', primaryjoin='Node.id==Datum.node_id', secondary=datumTable,
#         secondaryjoin='Datum.traitInstance_id==TraitInstance.id')
    attVals = relation('AttributeValue')

    def getId(self):
        return self.id
    def getRow(self):
        return self.row
    def getCol(self):
        return self.col

    @oneException2None
    def getAttributeValue(self, nodeAttributeId):
        return _dbc(self).query(AttributeValue).filter(
            and_(
                AttributeValue.node_id == self.id,
                AttributeValue.nodeAttribute_id == nodeAttributeId)
            ).one()

    def getNotes(self):
        dbc = Session.object_session(self)
        return dbc.query(NodeNote).filter(NodeNote.node_id == self.id).all()


class NodeAttribute(DeclarativeBase):
# Node attributes are used in the following ways:
# They are sent to the app (fpAppWapi) with trial definitions.
# They are retrieved from the rest API for statistics.
# They are shown in trial browse/download output.
# They are shown in node attribute lists on server.
#
# Node attributes can source the individual values from the attributeValue table,
# or from a traitInstance.
#
# Todo:
# Perhaps create a NodeAttribute for every traitInstance.
# Add a "downloadable" flag to explicitly record which attributes are sent to app.
#
    __tablename__ = 'nodeAttribute'
    __table_args__ = {}

    # column definitions
    id = Column(u'id', INTEGER(), primary_key=True, nullable=False)
    name = Column(u'name', VARCHAR(length=31), nullable=False)
    trial_id = Column(u'trial_id', INTEGER(), ForeignKey('trial.id'), nullable=False)
    datatype = Column(unicode(TUA_DATATYPE), INTEGER(), default=T_INTEGER, nullable=False)
    func = Column(unicode(TUA_FUNC), INTEGER(), default=0, nullable=False)

    # relation definitions
    trial = relation('Trial', primaryjoin='NodeAttribute.trial_id==Trial.id')
    nodes = relation('Node', primaryjoin='NodeAttribute.id==AttributeValue.nodeAttribute_id',
        secondary=attributeValueTable, secondaryjoin='AttributeValue.node_id==Node.id')
        
    def getId(self):
        return self.id;
    def fname(self):
        return self.name;
    def getName(self):
        return self.name;
    def getDatatypeText(self):
        dt = self.datatype
        if dt == T_INTEGER: return 'integer'
        elif dt == T_DECIMAL: return 'decimal'
        elif dt == T_STRING: return 'text'
        else:
            raise DalError('unexpected datatype ({}) in NodeAttribute'.format(dt))

    def setName(self, name):
        self.name = name

    def isTraitInstance(self):
        return self.func is not None and self.func > 0

    def getTraitInstance(self):
        if self.isTraitInstance():
            return getTraitInstance(_dbc(self), self.func)
        else:
            return None

    def getAttributeValues(self, latestOnly=True):
    #----------------------------------------------------
    # Returns a list of objects each representing one node with
    # associated value. The object type is not fixed (ATTOW they
    # will be AttributeValue or Datum), but they will have a
    # getNode function returning a Node object, and a getValueAsString
    # function. The object list is sorted by the contained by node Id.
    #
    # NB only returns attribute that exists (unlike getValues).
    # For traitInstances only the latest value for each node is returned.
    #
        ti = self.getTraitInstance()
        if ti is not None:
            # return ti.getNodeValues()
            return ti.getData(latestOnly)
        else:
            return _dbc(self).query(AttributeValue) \
                .filter(AttributeValue.nodeAttribute_id == self.id) \
                .order_by(AttributeValue.node_id.asc()) \
                .all()

    def getValues(self, orderByNodeId=False, missingValue=""):
    #-----------------------------------------------------------------------
    # Returns an array of attribute values with one entry for each node in the trial.
    # The entries are orderedby row/col by default, or node id if specified.
    # Missing values are given as the empty string or as specified.
    #
    # MFKNA Node attributes not polymorphic, (should we rename this class nodeProperty?)
    # Need to add "source" field.
        ti = self.getTraitInstance()
        if ti is not None:  # This is a traitInstance attribute
            return ti.getLatestDatumPerNodeAsString(quoteStrings=False, metadata=False, missingValue=missingValue, orderByNodeId=orderByNodeId)
        else:  # Normal attribute
            eng = _eng(self)  # pass this in?
            qry = """
                select a.value from node n left join attributeValue a
                on n.id = a.node_id and a.nodeAttribute_id = {0}
                where n.trial_id = {1}
                order by """ + ('n.id' if orderByNodeId else 'row,col')
            valList = []
            result = eng.execute(qry.format(self.id , self.trial.getId()))
            for row in result:
                valList.append(missingValue if row[0] is None else row[0])
            return valList

    @oneException2None
    def getUniqueNodeIdFromValue(self, val):
        return _dbc(self).query(AttributeValue.node_id) \
            .filter(and_(AttributeValue.nodeAttribute_id == self.id, AttributeValue.value == val)) \
            .one().node_id

class System(DeclarativeBase):
    __tablename__ = 'system'
    __table_args__ = {}
    name = Column(u'name', VARCHAR(length=63), primary_key=True, nullable=False)
    value = Column(u'value', VARCHAR(length=255), nullable=True)
    def __init__(self, name, value):
        self.name = name
        self.value = value
        super(System, self).__init__()

class NodeNote(DeclarativeBase):
    __tablename__ = 'nodeNote'
    __table_args__ = {}

    # column definitions:
    id = Column(u'id', INTEGER(), primary_key=True, nullable=False)
    node_id = Column(u'node_id', INTEGER(), ForeignKey('node.id'), nullable=False)
    timestamp = Column(u'timestamp', BigInteger(), primary_key=True, nullable=False)
    userid = Column(u'userid', TEXT())
    token_id = Column(u'token_id', INTEGER(), ForeignKey('token.id'), nullable=False)
    note = Column(u'note', TEXT())

    # relation definitions:
    node = relation('Node', primaryjoin='NodeNote.node_id==Node.id')
    token = relation('Token', primaryjoin='NodeNote.token_id==Token.id')

#
# class Token
# Used to record server tokens.
# It would be nice to rename token field to tokenStr..
class Token(DeclarativeBase):
    __tablename__ = 'token'
    __table_args__ = {}
    id = Column(u'id', INTEGER(), primary_key=True, nullable=False)
    token = Column(u'token', VARCHAR(length=31), unique=True, nullable=False)
    trial_id = Column(u'trial_id', INTEGER(), ForeignKey('trial.id'), nullable=False)

    def __init__(self, token, trialId):
        self.token = token
        self.trial_id = trialId
        super(Token, self).__init__()

    def getId(self):
        return self.id

    def getDeviceId(self):
        return self.token.split('.')[0]

    def getDownloadTime(self):
        return self.token.split('.')[1]

    def tokenString(self):
        return self.token

    @staticmethod
    def createNewToken(dbc, androidId, trialId):
    #-------------------------------------------------------------------------------------------------
    # Create new server token. Store it in the database.
    # Use the android device ID postfixed with the current time in seconds as the token string.
    # This should ensure different tokens for the same trial being downloaded multiple times on
    # a single device (with delete in between), as long as they are not created within the same
    # second (and this is not an expected use case):
    # Alternatively, perhaps we should use the token id as the token string, thus ensuring
    # uniqueness.
    #
        tokenStr = androidId + "." + str(int(time.time()))
        nt = Token(tokenStr, trialId)
        dbc.add(nt)
        dbc.commit()
        return nt

    @staticmethod
    @oneException2None
    def getToken(dbc, tokenStr, trialId):
    # Returns token id for token, or None if not found or other error.
        return dbc.query(Token).filter(Token.token == tokenStr).one()

    @staticmethod
    def getOrCreateToken(dbc, tokenStr, trialId):
    # Returns token id for token, creating new record if necessary.
    # Currently only used by fpTrial, to create a token for uploads initiated from the server.
        try:
            return dbc.query(Token).filter(Token.token == tokenStr).one()
        except NoResultFound:
            # Make new token
            nt = Token(tokenStr, trialId)
            dbc.add(nt)
            dbc.commit()
            return nt

    @staticmethod
    def getTokenId(dbc, token):
    # Returns token id for token, creating new record if necessary.
    # Throws exception if token not found.
        try:
            return dbc.query(Token).filter(Token.token == token).one().id
        except NoResultFound:
            raise DalError("Token not found")

#
# class TokenNode
# Used to record nodes created from devices, so as to avoid creating multiple copies.
#
class TokenNode(DeclarativeBase):
    __tablename__ = 'tokenNode'
    __table_args__ = {}
    token_id = Column(u'token_id', INTEGER(), ForeignKey('token.id'), primary_key=True, nullable=False)
    localId = Column(u'localId', INTEGER(), unique=True, primary_key=True, nullable=False)
    node_id = Column(u'node_id', INTEGER(), ForeignKey('node.id'), nullable=False)

    # relation definitions
    token = relation('Token', primaryjoin='TokenNode.token_id==Token.id')

    def __init__(self, tokenId, localId, nodeId):
        self.token_id = tokenId
        self.localId = localId
        self.node_id = nodeId
        super(TokenNode, self).__init__()

    @staticmethod
    def getOrCreateClientNode(dbc, tokenId, localId, trialId):
    # Create new tokenNode from given token and client local id, if not already created.
    # Returns the id of the new Node, or the already existing one.
    # MFK should trial Id be determined by token?
        try:
            tokNode = dbc.query(TokenNode).filter(
                and_(TokenNode.token_id == tokenId, TokenNode.localId == localId)).one()
            return getNode(dbc, tokNode.node_id)
        except NoResultFound:
            # Make new node
            newNode = Node()
            newNode.trial_id = trialId
            newNode.row = 0
            newNode.col = TokenNode.numCreatedNodesForTrial(dbc, trialId) + 1  # local node creation order in trial
            # count local nodes for the trial and add one.
            dbc.add(newNode)
            dbc.commit()  # commit to get the id

            # Create TokenNode
            newtn = TokenNode(tokenId, localId, newNode.id)
            dbc.add(newtn)
            dbc.commit()
            return newNode

    @staticmethod
    def numCreatedNodesForTrial(dbc, trialId):
        return dbc.query(TokenNode).join(TokenNode.token).filter(Token.trial_id == trialId).count()


###  Functions:  ##################################################################################################

gdbg = True

def _dbc(obj):
#------------------------------------------------------------------------
# Return database connection from given object (should be sqlalchemy class instance).
#
    return Session.object_session(obj)

def _eng(obj):
#------------------------------------------------------------------------
# Return engine associate given object (which should be sqlalchemy class instance),
# or None if can't get.
#
    sess = Session.object_session(obj)
    if sess is None:
        return None
    return sess.get_bind()

def dbName4Project(project):
#-----------------------------------------------------------------------
# Map project name to the database name.
# NB - only valid for projects with own db. Should probably not be used now.
    return 'fp_' + project

dbUser = None
dbPass = None
def _getDBLoginDetails():
#-------------------------------------------------------------------
# Sets globals dbUser and dbPass from file
    global dbUser, dbPass
    if dbUser is not None:
        return

    from config import FP_MYSQL_USER, FP_MYSQL_PASS
    dbUser = FP_MYSQL_USER
    dbPass = FP_MYSQL_PASS

    #pwfile = app.config['FPPWFILE']
    #with open(pwfile) as pwfile:
    #    dbdetails = pwfile.readline().rstrip().split(':', 1)
    #    dbUser = dbdetails[0]
    #    dbPass = dbdetails[1]

def fpPassword():
    _getDBLoginDetails()
    return dbPass

def fpDBUser():
    _getDBLoginDetails()
    return dbUser

def getSysUserEngine(projectName):
#-----------------------------------------------------------------------
# This should be called once only and the result stored,
# currently done in session module.
#
    dbname = fpsys.getProjectDBname(projectName)
    app.logger.debug("getSysUserEngine %s" % dbname)
    return getDbConnection(dbname)

def getDbConnection(dbname):
#-----------------------------------------------------------------------
# This should be called once only and the result stored,
# currently done in session module.
# MFK Note have had some problems with sql operations block on sleeping processes.
# Three separate things fixed it:
# . The use of poolclass=sqlalchemy.pool.NullPool commented out below.
# . Calling close on the session after using it.
# . Ensuring only one session by use of global var _FP_DBC.
# I'm sticking with this last method for the moment.
    app.logger.debug("getDbConnection %s" % dbname)

    global _FP_DBC
    global _FP_DBNAME
    if _FP_DBC is not None and dbname == _FP_DBNAME:
        app.logger.debug("getDbConnection: connection exists")
        return _FP_DBC

    from config import FP_MYSQL_HOST, FP_MYSQL_PORT
    engine = create_engine('mysql://{0}:{1}@{2}:{3}/{4}'.format(fpDBUser(), fpPassword(), FP_MYSQL_HOST, FP_MYSQL_PORT, dbname))
                            #poolclass=sqlalchemy.pool.NullPool)
    Session = sessionmaker(bind=engine)
    _FP_DBC = Session()
    _FP_DBNAME = dbname
    return _FP_DBC

# This should use alchemy and return connection
def dbConnectAndAuthenticate(project, password):
#-------------------------------------------------------------------------------------------------
    dbc = getSysUserEngine(project)  # not sure how this returns error, test..
    app.logger.debug(dbc)
    if dbc is None:
        return (None, 'Unknown user/database')

    # Check login:
    try:
        sysPwRec = dbc.query(System).filter(System.name == 'appPassword').one()
    except NoResultFound:
        # No password means OK to use:
        return dbc, None
    except MultipleResultsFound:
        # Shouldn't happen:
        return None, 'DB error, multiple passwords'
    except sqlalchemy.exc.OperationalError, e:
        app.logger.debug(e)
        return None, 'Error - may be invalid project name'
    # Note if there is a db problem, eg project incorrect we will have an unhandled exception.
    # Which is probably what we want since we'll get a backtrace in the log.

    if sysPwRec.value == password:
        return dbc, None
    return None, 'Invalid password'


@oneException2None
def getTrial(dbc, trialID):
#-----------------------------------------------------------------------
# Returns trial object with given id if found, else None.
    return dbc.query(Trial).filter(Trial.id == trialID).one()

@oneException2None
def getTraitInstance(dbc, traitInstance_id):
#-----------------------------------------------------------------------
# Returns traitInstance object with given id if found, else None.
    return dbc.query(TraitInstance).filter(TraitInstance.id == traitInstance_id).one()

def getTrait(dbc, traitId):
#-------------------------------------------------------------------------------------------------
    try:
        trt = dbc.query(Trait).filter(Trait.id == traitId).one()
    except sqlalchemy.exc.SQLAlchemyError, e:
        return None
    return trt

@oneException2None
def getNode(dbc, nodeId):
#-----------------------------------------------------------------------
# Return node with the given id.
    return dbc.query(Node).filter(Node.id == nodeId).one()


@oneException2None
def getTrialTrait(dbc, trialId, traitId):
#-------------------------------------------------------------------------------------------------
    return dbc.query(TrialTrait).filter(
        and_(TrialTrait.trait_id == traitId, TrialTrait.trial_id == trialId)).one()


def getTrialList(dbc):
#-------------------------------------------------------------------------------------------------
    try:
        trlList = dbc.query(Trial).all()
    except sqlalchemy.exc.SQLAlchemyError, e:
        return None
    return trlList

def getTrialListByProject(dbc,project_name):
#-------------------------------------------------------------------------------------------------
    try:
        project = dbc.query(Project).filter(Project.name == project_name).one()
        trlList = dbc.query(Trial).filter(Trial.project_id == project.id)
    except sqlalchemy.exc.SQLAlchemyError, e:
        return []
    return trlList


def getOrCreateTraitInstance(dbc, traitID, trialID, seqNum, sampleNum, dayCreated, tokenStr):
#-------------------------------------------------------------------------------------------------
# Get the trait instance, if it exists, else make a new one,
# In either case, we need the id.
# Note how trait instances from different devices are handled
# Trait instances are uniquely identified by trial/trait/seqNum/sampleNum and token.
# That is, using this data from the client. We need to be able to identify when a traitInstance
# sent from the client is one we have already seen.
# NB, ATTOW the seqnum sent from the client is, effectively, a (client local) scoreSet ID, consequently
# traitId, trialId and dayCreated should not be necessary to uniquely identify it. We could use something
# like the tokenNode table to store the map between that id and a scoreSet table (or with sampleNum to
# a traitInstance).
#
    util.flog("getOrCreateTraitInstance: {0} {1} {2} {3} {4} {5}".format(traitID, trialID, seqNum, sampleNum,
        dayCreated, tokenStr))

    # Get the token id:
    tokenId = Token.getTokenId(dbc, tokenStr)

    tiSet = dbc.query(TraitInstance).filter(and_(
            TraitInstance.trait_id == traitID,
            TraitInstance.trial_id == trialID,
            TraitInstance.seqNum == seqNum,
            TraitInstance.sampleNum == sampleNum,
            TraitInstance.token_id == tokenId,
            TraitInstance.dayCreated == dayCreated
            )).all()
    if len(tiSet) == 1:
        # Already exists:
        dbTi = tiSet[0]
    elif len(tiSet) == 0:
        # Doesn't exist: create it, and if needs a scoreSet:
        dbTi = TraitInstance()
        dbTi.trial_id = trialID
        dbTi.trait_id = traitID
        dbTi.dayCreated = dayCreated
        dbTi.seqNum = seqNum
        dbTi.sampleNum = sampleNum
        dbTi.token_id = tokenId
        dbc.add(dbTi)
        dbc.commit()
    else:
        return None
    return dbTi

@oneException2None
def getAttribute(dbc, attId):
    return dbc.query(NodeAttribute).filter(NodeAttribute.id == attId).one()

# Deprecate - replace with TraitInstance.addData
def AddTraitInstanceData(dbc, tiID, trtType, aData):
#-------------------------------------------------------------------------------------------------
# Insert or update datum records for specified trait instance.
# Params:
# dbc - db connection
# tiID - id of trait instance
# trtType - type of trait instance
# aData - array of data values, json from device
#
# Return None for success, else an error message.
#
    # Construct list of dictionaries of values to insert:
    try:
        valueFieldName = 'txtValue' if  trtType == T_STRING or trtType == T_PHOTO else 'numValue'
        dlist = []

        for jdat in aData:
            dlist.append({
                 'node_id' : (jdat.get(jDataUpload['node_id']) or jdat.get('trialUnit_id')),
                 'traitInstance_id' : tiID,
                 'timestamp' : jdat[jDataUpload['timestamp']],
                 'gps_long' : jdat[jDataUpload['gps_long']],
                 'gps_lat' : jdat[jDataUpload['gps_lat']],
                 'userid' : jdat[jDataUpload['userid']],
                 valueFieldName : jdat[jDataUpload['value']] if jDataUpload['value'] in jdat else None
            })
        # Note we use ignore because the same data items may be uploaded more than
        # once, and this should not cause the insert to fail.
        insob = datumTable.insert().prefix_with("ignore")
        res = dbc.execute(insob, dlist)
        dbc.commit()
        return None
    except Exception, e:
        return "An error occurred"

# Deprecate - replace with TraitInstance.addDatum
def AddTraitInstanceDatum(dbc, tiID, trtType, nodeId, timestamp, userid, gpslat, gpslong, value):
#-------------------------------------------------------------------------------------------------
# Insert or update datum records for specified trait instance.
# Params:
# dbc - db connection
# tiID - id of trait instance
# trtType - type of trait instance
# aData - array of data values, json from device
#
# Return None for success, else an error message.
#
    # Construct list of dictionaries of values to insert:
    try:
        valueFieldName = Datum.valueFieldName(trtType)
        ins = datumTable.insert().prefix_with('ignore').values({
             DM_NODE_ID: nodeId,
             DM_TRAITINSTANCE_ID : tiID,
             DM_TIMESTAMP : timestamp,
             DM_GPS_LONG : gpslong,
             DM_GPS_LAT : gpslat,
             DM_USERID : userid,
             valueFieldName : value
        })
        res = dbc.execute(ins)
        dbc.commit()
        return None
    except Exception, e:
        util.flog('AddTraitInstanceDatum: {0},{1},{2},{3},{4},{5}'.format(tiID, trtType, nodeId, timestamp, userid, gpslat))
        util.flog(e.__doc__)
        util.flog(e.message)
        return "An error occurred"

@oneException2None
def getSystemValue(dbc, name):
    return dbc.query(System).filter(System.name == name).one().value

def setSystemValue(dbc, name, value):
#-----------------------------------------------------------------------
# Insert or update new system value.
    sysItem = System(name, value)
    sysItem = dbc.merge(sysItem)
    dbc.commit()


def addNodeNotes(dbc, tokenStr, notes):
#-------------------------------------------------------------------------------------------------
# Return None for success, else an error message.
# MFK need check nodeIds are in correct trial
#
    # Convert tokenStr to its token id. The token should exist in the token table,
    # otherwise something fishy may be going on.
    try:
        tokenId = Token.getTokenId(dbc, tokenStr)
    except Exception, e:
        return "Token not found ({0})".format(e.__str__())

    qry = 'insert ignore into {0} ({1}, {2}, {3}, {4}, {5}) values '.format(
        'nodeNote', 'node_id', 'timestamp', 'userid', 'token_id', 'note')
    if len(notes) <= 0:
        return None
    for n in notes:
        try:
            nodeId = n.get(jNotesUpload['node_id']) or n.get('trialUnit_id')
            qry += '({0}, {1}, "{2}", {3}, "{4}"),'.format(
                nodeId, n[jNotesUpload['timestamp']],
                n[jNotesUpload['userid']], tokenId, n[jNotesUpload['note']])
            # Should be this, but have to cope with 'trialUnit_id' coming
            # from clients for a while..
            # qry += '({0}, {1}, "{2}", {3}, "{4}"),'.format(
            #     n[jNotesUpload['node_id']], n[jNotesUpload['timestamp']],
            #     n[jNotesUpload['userid']], tokenId, n[jNotesUpload['note']])
        except Exception, e:
            return 'Error parsing note ' + e.args[0]

    qry = qry[:-1]  # Remove last comma
    # call sql to do multi insert:
    dbc.bind.execute(qry)
    return None;


def CreateTrait2(dbc, caption, description, vtype, sysType, vmin, vmax):
#--------------------------------------------------------------------------
# Creates a trait with the passed values and writes it to the db.
# Returns a list [ <new trait> | None, ErrorMessage | None ]
# NB doesn't add to trialTrait table
# Currently only written with adhoc traits in mind..
#
    # We need to check that caption is unique within the trial - for local anyway, or is this at the add to trialTrait stage?
    # For creation of a system trait, there is not an automatic adding to a trial, so the uniqueness-within-trial test
    # can wait til the adding stage.
    ntrt = Trait(caption, description, vtype, False, None)  # MFK - won't work, not used attow.
    ntrt.caption = caption
    ntrt.description = description
    ntrt.sysType = sysType

    # Check for duplicate captions, probably needs to use transactions or something, but this will usually work:
    # and add to trialTrait?
    if sysType == SYSTYPE_TRIAL:  # If local, check there's no other trait local to the trial with the same caption:
        # trial = GetTrialFromDBsess(sess, tid)
        # for x in trial.traits:
        #     if x.caption == caption:
        #         return (None, "Duplicate caption")
        # ntrt.trials = [trial]      # Add the trait to the trial (table trialTrait)
        pass
    elif sysType == SYSTYPE_SYSTEM:  # If system trait, check there's no other system trait with same caption:
        # sysTraits = dbUtil.GetSysTraits(sess)
        # for x in sysTraits:
        #     if x.caption == caption:
        #         return (None, "Duplicate caption")
        pass
    elif sysType == SYSTYPE_ADHOC:
        # Check no trait with same caption that's not an adhoc trait for another device
        # Do adhoc traits go into trialTrait?
        # Perhaps not at the moment, but perhaps they should be..
        pass
    else:
        return (None, "Invalid sysType")

    # MFK min and max now in separate table, but since this function currently never used, I won't fix now.
#     if vmin:
#         ntrt.min = vmin
#     if vmax:
#         ntrt.max = vmax
    dbc.add(ntrt)
    dbc.commit()
    return ntrt, None

# MFK these functions should probably be replace by method on trait.
# Something generic like get trial trait json details.
def GetTrialTraitNumericDetails(dbc, trait_id, trial_id):
# Return TrialTraitNumeric for specified trait/trial, or None if none exists.
    tti = dbc.query(TrialTraitNumeric).filter(and_(
            TrialTraitNumeric.trait_id == trait_id,
            TrialTraitNumeric.trial_id == trial_id
            )).all()
    if len(tti) == 1:
        ttid = tti[0]
        return ttid
    return None

def getTraitString(dbc, trait_id, trial_id):
# Return TraitString for specified trait/trial, or None if none exists.
    ttlist = dbc.query(TraitString).filter(and_(
            TraitString.trait_id == trait_id,
            TraitString.trial_id == trial_id
            )).all()
    if len(ttlist) == 1:
        return ttlist[0]
    return None


def photoFileName(dbusername, trialId, traitId, nodeId, tokenStr, seqNum, sampNum):
# Return the file name (not including directory) of the photo for the score with the specified attributes.
    return '{0}_{1}_{2}_{3}_{4}_{5}_{6}.jpg'.format(dbusername, trialId, traitId, nodeId, tokenStr, seqNum, sampNum)

def valueFromString(dtype, valString):
#---------------------------------------------------------------
# Return value from string, if valid for datatype, else None.
# NB not all types supported, non supported types return None.
#
    try:
        if dtype == T_INTEGER: return int(valString)
        elif dtype == T_DECIMAL: return decimal.Decimal(valString)
        elif dtype == T_STRING: return valString
        elif dtype == T_CATEGORICAL: return None
#             value = self.numValue
#             # Need to look up the text for the value:
#             if value is not None:
#                 session = Session.object_session(self)
#                 traitId = self.traitInstance.trait.id
#                 trtCat = session.query(TraitCategory).filter(
#                     and_(TraitCategory.trait_id == traitId, TraitCategory.value == value)).one()
#                 value = trtCat.caption
        elif dtype == T_DATE: return int(valString)
        elif dtype == T_PHOTO: return None
        else:
            return None
    except ValueError:
        return None
    except decimal.InvalidOperation:
        return None

def datatypeName(dtypeCode):
    try:
        return TRAIT_TYPE_NAMES[dtypeCode]
    except (IndexError, TypeError):
        return None



